from math import inf
from typing import Any


class Node:
    def __init__(self, data, left=None, right=None) -> None:
        self.data = data
        self.left = left
        self.right = right


def print_tree(arr, val="data", left="left", right="right") -> None:
    def build_tree(arr) -> Node | None:
        # funtion to build tree from an array, where "N" represents empty node
        def grab(it, next_level) -> Node | None:
            value = next(it, "N")
            if value != "N":
                node = Node(data=value)
                next_level.append(node)
                return node

        # Create the root of the tree
        it = iter(arr)
        next_level = []
        root = grab(it=it, next_level=next_level)

        while next_level:
            level = next_level
            next_level = []
            for node in level:
                node.left = grab(it=it, next_level=next_level)
                node.right = grab(it=it, next_level=next_level)

        return root

    # function to print tree in a grahical way
    def display(root, val=val, left=left, right=right) -> Any:
        # Returns list of strings, width, height, and horizontal coordinate of the root.
        # No child.
        if getattr(root, right) is None and getattr(root, left) is None:
            line = "%s" % getattr(root, val)
            width = len(line)
            height = 1
            middle = width // 2
            return [line], width, height, middle

        # Only left child.
        if getattr(root, right) is None:
            lines, n, p, x = display(getattr(root, left))
            s = "%s" % getattr(root, val)
            u = len(s)
            first_line = (x + 1) * " " + (n - x - 1) * "_" + s
            second_line = x * " " + "/" + (n - x - 1 + u) * " "
            shifted_lines = [line + u * " " for line in lines]
            return (
                [first_line, second_line] + shifted_lines,
                n + u,
                p + 2,
                n + u // 2,
            )

        # Only right child.
        if getattr(root, left) is None:
            lines, n, p, x = display(root=getattr(root, right))
            s = "%s" % getattr(root, val)
            u = len(s)
            first_line = s + x * "_" + (n - x) * " "
            second_line = (u + x) * " " + "\\" + (n - x - 1) * " "
            shifted_lines = [u * " " + line for line in lines]
            return [first_line, second_line] + shifted_lines, n + u, p + 2, u // 2

        # Two children.
        left, n, p, x = display(root=getattr(root, left))
        right, m, q, y = display(root=getattr(root, right))
        s = "%s" % getattr(root, val)
        u = len(s)
        first_line = (x + 1) * " " + (n - x - 1) * "_" + s + y * "_" + (m - y) * " "
        second_line = (
            x * " " + "/" + (n - x - 1 + u + y) * " " + "\\" + (m - y - 1) * " "
        )
        if p < q:
            left += [n * " "] * (q - p)
        elif q < p:
            right += [m * " "] * (p - q)
        zipped_lines = zip(left, right, strict=True)
        lines = [first_line, second_line] + [a + u * " " + b for a, b in zipped_lines]
        return lines, n + m + u, max(p, q) + 2, n + u // 2

    root = build_tree(arr)
    lines, *_ = display(root=root, val=val, left=left, right=right)
    for line in lines:
        print(line)


class Heap:
    def __init__(self, arr=[], min_heap=None) -> None:
        self.arr = arr
        if len(arr) <= 1:
            if not min_heap:
                self.min_heap = True
            else:
                self.min_heap = min_heap
        else:
            self.min_heap = arr[0] < arr[1]

    def get_parent(self, pos) -> int:
        return (pos - 1) // 2

    def get_left_child(self, pos) -> int:
        return pos * 2 + 1

    def get_right_child(self, pos) -> int:
        return pos * 2 + 2

    def print_tree(self) -> None:
        print_tree(arr=self.arr)

    def insert(self, value) -> None:
        arr = self.arr
        arr.append(value)
        i = len(arr) - 1

        if self.min_heap:
            while i > 0 and arr[i] < arr[self.get_parent(pos=i)]:
                p = self.get_parent(pos=i)
                arr[i], arr[p] = arr[p], arr[i]
                i = p
            return
        else:
            while i > 0 and arr[i] > arr[self.get_parent(pos=i)]:
                p = self.get_parent(pos=i)
                arr[i], arr[p] = arr[p], arr[i]
                i = p
            return

    def min_heapify(self, pos) -> None:
        arr = self.arr
        lt = self.get_left_child(pos=pos)
        rt = self.get_right_child(pos=pos)
        smallest = pos
        n = len(arr)
        if lt < n and arr[lt] < arr[smallest]:
            smallest = lt
        if rt < n and arr[rt] < arr[smallest]:
            smallest = rt
        if smallest != pos:
            arr[smallest], arr[pos] = arr[pos], arr[smallest]
            self.min_heapify(pos=smallest)

    def extract_min(self) -> Any:
        arr = self.arr
        n = len(arr)
        if n == 0:
            return inf
        res = arr[0]
        arr[0] = arr[n - 1]
        arr.pop()
        self.min_heapify(pos=0)
        return res

    def max_heapify(self, pos) -> None:
        arr = self.arr
        lt = self.get_left_child(pos=pos)
        rt = self.get_right_child(pos=pos)
        largest = pos
        n = len(arr)
        if lt < n and arr[lt] > arr[largest]:
            largest = lt
        if rt < n and arr[rt] > arr[largest]:
            largest = rt
        if largest != pos:
            arr[largest], arr[pos] = arr[pos], arr[largest]
            self.max_heapify(pos=largest)

    def extract_max(self) -> Any:
        arr = self.arr
        n = len(arr)
        if n == 0:
            return -inf
        res = arr[0]
        arr[0] = arr[n - 1]
        arr.pop()
        self.max_heapify(pos=0)
        return res


if __name__ == "__main__":
    hp_min = Heap(arr=[10, 20, 15, 40, 50, 100, 25, 45])
    hp_min.print_tree()
    hp_min.insert(value=12)
    hp_min.print_tree()
    hp_min.extract_min()
    hp_min.print_tree()

    hp_max = Heap(arr=[100, 50, 25, 45, 40, 25, 20, 10])
    hp_max.print_tree()
    hp_max.insert(value=75)
    hp_max.print_tree()
    hp_max.extract_max()
    hp_max.print_tree()
